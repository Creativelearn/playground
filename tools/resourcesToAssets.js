const nanoid = require('nanoid')

module.exports = async (db, workspaceId) => {
  const templatesToMigrate = await db.collection('templates').find({ workspaceId, resources: { $ne: null, $exists: true } }).project({ _id: 1, resources: 1, scripts: 1, folder: 1 }).toArray()

  const templateToAssetResourcesMap = new Map()
  const dataToAssetMap = new Map()
  const dataEntitiesToRemove = []

  for (const template of templatesToMigrate) {
    if (Array.isArray(template.resources.items)) {
      for (const dataItem of template.resources.items) {
        const dataEntity = await db.collection('data').findOne({ shortid: dataItem.shortid, workspaceId })

        if (dataEntity) {
          let newAsset

          if (dataToAssetMap.has(dataEntity._id.toString())) {
            newAsset = dataToAssetMap.get(dataEntity._id.toString())
          } else {
            newAsset = await insertUnique(db, workspaceId, dataEntity.folder, 'assets', `${dataEntity.name}.json`, {
              content: Buffer.from(dataEntity.dataJson || ''),
              folder: dataEntity.folder || null
            })

            dataToAssetMap.set(dataEntity._id.toString(), newAsset)
          }

          const assetResources = templateToAssetResourcesMap.get(template._id.toString()) || []

          assetResources.push({
            ...newAsset,
            originalName: dataEntity.name
          })

          templateToAssetResourcesMap.set(template._id.toString(), assetResources)
          dataEntitiesToRemove.push(dataEntity._id)
        }
      }
    }

    const templateAssetResources = templateToAssetResourcesMap.get(template._id.toString()) || []

    if (templateAssetResources.length > 0) {
      const newScript = await insertUnique(db, workspaceId, template.folder, 'scripts', 'resources', {
        content: (
`
// THIS SCRIPT WAS GENERATED BY MIGRATION IN V3, IT PROVIDES BACKWARD COMPATIBILITY
// WITH THE DEPRECATED jsreport-resources https://jsreport.net/learn/resources
// THE RECOMMENDATION NOW IS TO USE jsreport-localization https://jsreport.net/learn/localization
// SO WHEN YOU DECIDE TO USE jsreport-localization TO FULLY REPLACE THE jsreport-resources
// JUST REMOVE THIS SCRIPT FROM YOUR TEMPLATE AND DELETE IT
const jsreport = require('jsreport-proxy')

async function beforeRender (req, res) {
  req.options.language = req.options.language || req.template.localization?.language  
  const defaultLanguage = ${template.resources.defaultLanguage != null ? '\'' + template.resources.defaultLanguage + '\'' : 'undefined'}  
  const assetsResources = [${templateAssetResources.map(a => `{ name: '${a.originalName}', shortid: '${a.shortid}' }`).join(', ')}]

  const resources = await Promise.all(assetsResources.map(async (r) => {
    const asset = await jsreport.documentStore.collection('assets').findOne({ shortid: r.shortid })

    if (asset == null) {
      throw new Error(\`Asset resources with shortid \${r.shortid} was not found (resource lookup)\`)
    }

    asset.resourceName = r.name
    asset.content = asset.content.toString()

    return asset
  }))

  resources.forEach((r) => {
    r.dataJson = r.content
    r.data = JSON.parse(r.content)
  })

  req.options.resources = resources
  req.data.$resources = resources

  const resourcesByName = {}

  resources.forEach((r) => {
    resourcesByName[r.resourceName] = r.data
  })

  req.options.resource = resourcesByName
  req.data.$resource = resourcesByName

  const isLocalizedRequest = req.options.language != null || defaultLanguage != null

  if (isLocalizedRequest) {
    let languageUsed
    let applicableResources = []

    if (req.options.language) {
      languageUsed = req.options.language
      applicableResources = resources.filter((r) => r.resourceName.startsWith(\`\${languageUsed}-\`))
    }

    if (!applicableResources.length && defaultLanguage) {
      languageUsed = defaultLanguage
      applicableResources = resources.filter((r) => r.resourceName.startsWith(\`\${languageUsed}-\`))
    }

    console.log(\`Found \${applicableResources.length} resources for language "\${languageUsed}"\`)

    req.options.localizedResources = applicableResources
    req.data.$localizedResources = applicableResources

    const localizedResourceByName = {}

    applicableResources.forEach((r) => {
      localizedResourceByName[r.resourceName.substring(\`\${languageUsed}-\`.length)] = r.data
    })

    req.options.localizedResource = applicableResources.length === 1 ? applicableResources[0].data : localizedResourceByName
    req.data.$localizedResource = req.options.localizedResource
  }
}
`
        ),
        folder: template.folder || null
      })

      template.scripts = template.scripts || []

      template.scripts.unshift({
        shortid: newScript.shortid
      })
    }

    template.resources = null

    await db.collection('templates').update({ _id: template._id, workspaceId }, { $set: template })
  }

  for (const dataEntityId of dataEntitiesToRemove) {
    await db.collection('data').remove({ _id: dataEntityId, workspaceId })
  }
}

async function insertUnique (db, workspaceId, folder, collectionName, baseName, entity) {
  let tryCount = 0

  while (true) {
    const entityName = '_'.repeat(tryCount) + baseName

    const existingEntity = await findInAll(db, workspaceId, entityName, folder)
    if (existingEntity) {
      tryCount++
      continue
    }

    const newEntity = {
      ...entity,
      name: entityName,
      workspaceId,
      shortid: nanoid(7),
      modificationDate: new Date(),
      creationDate: new Date()
    }
    await db.collection(collectionName).insertOne(newEntity)
    return newEntity
  }
}

async function findInAll (db, workspaceId, name, folder) {
  for (const col of ['templates', 'scripts', 'assets', 'data', 'folders', 'tags', 'components']) {
    const existingEntity = await db.collection(col).findOne({ name, workspaceId, folder: folder || null })
    if (existingEntity) {
      return existingEntity
    }
  }
  return null
}
